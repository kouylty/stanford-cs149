### Programming Assignment 2 笔记

kouylty



#### 【写在前面】

第四到六次的 lecture 主要介绍了并行程序的一些编程范式。如果线程之间想要共享数据和同步化（synchronization），就必须使用锁（mutex）和障碍（barrier）。因为 Amdahl's Law 的存在，我们想要提高并行程序的效率，就必须找到效率最高的任务划分和分配方案（scheduling），包括静态分配和动态分配。因为我们不能每次都很好的估算每个任务消耗的时间，因此动态分配（dynamic scheduling）是很常用的。其中，为了减少创建线程和合并线程的消耗，我们往往采用线程池（thread pool）的方式，只要有线程空闲，就从任务队列中窃取一个任务运算。

Assignment 2 就是要实现一个并行计算的库，类似于简易的 ISPC 模拟器，包括线程池管理等内容。



#### 【Part A】

**Step 1**

这是最基础的并行程序，即对每一次 ```run``` 的调用都新创建线程然后都 ```join``` 起来。

**Step 2**

我们要在此构建一个线程池，每次调用 ```run``` 时，都在任务队列里插入新任务，让每个线程窃取任务并执行。空闲的线程称为在旋转（spinning）。除此之外，我们还要再维护一个 ```atomic<int> task_left```，用于记录已经还未完成的任务数。```run``` 函数要等所有任务都完成后再返回。

**Step 3**

在上一步中，我们线程池中的线程始终是活跃的，在线程空闲的时候依然会消耗硬件资源。因此我们想在线程空闲并且没有新任务的时候让它休眠（sleep），等到有新任务给它时再唤醒。这就需要用到 ```condition_variable```。

根据 tutorial 和 cppreference 的内容，稍微学了一下 ```condition_variable```，但理解还是不够深入，只能按照示例代码依葫芦画瓢。

```condition_variable``` 有两个主要的操作：```wait``` 和 ```notify```。

```wait``` 以一个特殊锁（```unique_lock```）为参数，调用时让线程休眠，直到条件满足时再唤醒。```notify``` 可以提醒其他休眠的线程检查锁的条件是否满足，分为 ```notify_all``` 和 ```notify_one``` 两种。

具体实现时，除了让线程池中的子线程休眠，再 ```run``` 等待子线程完成任务的过程中，也可以调用 ```wait``` 让主线程休眠。依然维护 ```task_left```，如果还有新任务，那就 ```notify``` 所有线程准备迎接新任务；如果任务全部完成，那就 ```notify``` 主线程让它返回。



#### 【Part B】

在这一部分，我们不要每次都等待 ```run``` 返回，因为这样并不能一下展示（reveal）所有的任务，会有大量的空闲线程消耗。我们异步（asynchronously）执行任务，获取任务包（task bulk）后，就先让 ```run``` 返回，同时返回一个 ```bulk_id``` 用于判断这个任务包是否已经全部完成。为此，我们建立两个结构体 ```TaskBulk``` 和 ```RunnableTask``` 用于维护信息。

然后就是对任务依赖的处理，这一块用一个优先队列（priority queue）排序一下就好，类似拓扑排序。在 ```sync``` 中，对于每一个可以执行的任务包，我们就把其中的任务塞进任务队列里，并 ```notify``` 所有子线程。直到所有任务包都已经完成，```sync``` 返回。

主体部分与 Part A Step 3 相似。

